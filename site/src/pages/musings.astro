---
import BaseLayout from '../layouts/BaseLayout.astro';
import { getCollection } from 'astro:content';

// In production, only show published entries; in dev, show all non-draft entries
const allEntries = await getCollection('journal', ({ data }) =>
  !data.draft
);

// Sort reverse chronologically (newest first)
const sortedEntries = allEntries.sort((a, b) =>
  new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
);

const formatDate = (date: Date) => {
  return date.toLocaleDateString('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric'
  });
};
---

<BaseLayout title="Timeline | Journal">
  <div class="timeline-header">
    <h1 class="page-title">Timeline</h1>
    <div class="search-container" id="search-container">
      <span class="search-prefix">/</span>
      <input
        type="text"
        id="search-input"
        class="search-input"
        placeholder="search..."
        autocomplete="off"
      />
    </div>
  </div>

  {sortedEntries.length === 0 ? (
    <p class="empty-state">No entries yet.</p>
  ) : (
    <ul class="entry-list" id="entry-list">
      {sortedEntries.map((entry, index) => (
        <li data-index={index}>
          <a href={`/${entry.slug}`} class="entry-link" data-title={entry.data.title.toLowerCase()}>
            <time class="entry-date">{formatDate(new Date(entry.data.date))}</time>
            <span class="entry-title">{entry.data.title}</span>
            {entry.data.mood && <span class="entry-mood">{entry.data.mood}</span>}
          </a>
        </li>
      ))}
    </ul>
  )}

  <div class="vim-hint" id="vim-hint">
    <kbd>/</kbd> search <kbd>j</kbd><kbd>k</kbd> navigate <kbd>enter</kbd> open <kbd>esc</kbd> close
  </div>
</BaseLayout>

<style>
  .timeline-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 2rem;
    gap: 1rem;
  }

  .page-title {
    font-family: var(--font-display);
    font-size: var(--text-lg);
    font-weight: 400;
    font-style: italic;
    color: var(--fg-muted);
    margin: 0;
  }

  .search-container {
    display: none;
    align-items: center;
    gap: 0.25rem;
    font-family: var(--font-mono);
    font-size: var(--text-sm);
  }

  .search-container.active {
    display: flex;
  }

  .search-prefix {
    color: var(--accent);
  }

  .search-input {
    background: transparent;
    border: none;
    border-bottom: 1px solid var(--border-color);
    color: var(--fg);
    font-family: var(--font-mono);
    font-size: var(--text-sm);
    padding: 0.25rem 0;
    width: 150px;
    outline: none;
  }

  .search-input:focus {
    border-bottom-color: var(--accent);
  }

  .empty-state {
    color: var(--fg-muted);
  }

  .entry-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .entry-list li {
    border-bottom: 1px solid var(--border-color);
  }

  .entry-list li:last-child {
    border-bottom: none;
  }

  .entry-list li.hidden {
    display: none;
  }

  .entry-list li.selected .entry-link {
    background: var(--bg-elevated);
    margin: 0 -1rem;
    padding: 0.75rem 1rem;
  }

  .entry-list li.selected .entry-date {
    color: var(--fg);
  }

  .entry-list li.selected .entry-title {
    color: var(--fg);
  }

  .entry-link {
    display: flex;
    align-items: baseline;
    gap: 1rem;
    padding: 0.75rem 0;
    text-decoration: none;
    color: var(--fg);
    border: none;
    transition: background 100ms, padding 100ms, margin 100ms;
  }

  .entry-link:hover {
    opacity: 0.7;
  }

  .entry-date {
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    color: var(--accent);
    min-width: 6rem;
  }

  .entry-title {
    flex: 1;
    color: var(--fg-muted);
  }

  .entry-mood {
    font-size: var(--text-sm);
    color: var(--fg-muted);
  }

  .vim-hint {
    position: fixed;
    bottom: 1rem;
    right: 1rem;
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    color: var(--fg-muted);
    opacity: 0.5;
    display: flex;
    gap: 0.75rem;
    align-items: center;
  }

  .vim-hint kbd {
    background: var(--bg-elevated);
    border: 1px solid var(--border-color);
    padding: 0.125rem 0.375rem;
    font-size: var(--text-xs);
  }

  @media (max-width: 640px) {
    .vim-hint {
      display: none;
    }
  }
</style>

<script>
  const searchContainer = document.getElementById('search-container');
  const searchInput = document.getElementById('search-input') as HTMLInputElement;
  const entryList = document.getElementById('entry-list');
  const entries = entryList?.querySelectorAll('li') || [];

  let selectedIndex = -1;
  let isSearchActive = false;
  let visibleEntries: HTMLLIElement[] = [];

  function updateVisibleEntries() {
    visibleEntries = Array.from(entries).filter(
      (li) => !li.classList.contains('hidden')
    ) as HTMLLIElement[];
  }

  function clearSelection() {
    entries.forEach((li) => li.classList.remove('selected'));
  }

  function selectEntry(index: number) {
    clearSelection();
    if (index >= 0 && index < visibleEntries.length) {
      selectedIndex = index;
      visibleEntries[index].classList.add('selected');
      visibleEntries[index].scrollIntoView({ block: 'nearest' });
    }
  }

  function openSearch() {
    isSearchActive = true;
    searchContainer?.classList.add('active');
    searchInput?.focus();
    updateVisibleEntries();
    if (selectedIndex === -1 && visibleEntries.length > 0) {
      selectEntry(0);
    }
  }

  function closeSearch() {
    isSearchActive = false;
    searchContainer?.classList.remove('active');
    if (searchInput) searchInput.value = '';
    entries.forEach((li) => li.classList.remove('hidden'));
    clearSelection();
    selectedIndex = -1;
    updateVisibleEntries();
  }

  function filterEntries(query: string) {
    const q = query.toLowerCase();
    entries.forEach((li) => {
      const link = li.querySelector('.entry-link') as HTMLAnchorElement;
      const title = link?.dataset.title || '';
      if (title.includes(q)) {
        li.classList.remove('hidden');
      } else {
        li.classList.add('hidden');
      }
    });
    updateVisibleEntries();
    if (visibleEntries.length > 0) {
      selectEntry(0);
    } else {
      selectedIndex = -1;
      clearSelection();
    }
  }

  function navigateToSelected() {
    if (selectedIndex >= 0 && selectedIndex < visibleEntries.length) {
      const link = visibleEntries[selectedIndex].querySelector('.entry-link') as HTMLAnchorElement;
      if (link) window.location.href = link.href;
    }
  }

  // Global keyboard handler
  document.addEventListener('keydown', (e) => {
    const active = document.activeElement;
    const isInputFocused = active?.tagName === 'INPUT' ||
                           active?.tagName === 'TEXTAREA' ||
                           (active as HTMLElement)?.isContentEditable;

    // Handle search input
    if (isSearchActive && active === searchInput) {
      if (e.key === 'Escape') {
        e.preventDefault();
        closeSearch();
        return;
      }
      if (e.key === 'Enter') {
        e.preventDefault();
        navigateToSelected();
        return;
      }
      if (e.key === 'ArrowDown' || (e.ctrlKey && e.key === 'n')) {
        e.preventDefault();
        if (selectedIndex < visibleEntries.length - 1) {
          selectEntry(selectedIndex + 1);
        }
        return;
      }
      if (e.key === 'ArrowUp' || (e.ctrlKey && e.key === 'p')) {
        e.preventDefault();
        if (selectedIndex > 0) {
          selectEntry(selectedIndex - 1);
        }
        return;
      }
      return;
    }

    // Don't handle if input focused
    if (isInputFocused) return;

    // Vim-style navigation
    if (e.key === '/') {
      e.preventDefault();
      openSearch();
      return;
    }

    if (e.key === 'j') {
      e.preventDefault();
      updateVisibleEntries();
      if (selectedIndex < visibleEntries.length - 1) {
        selectEntry(selectedIndex + 1);
      } else if (selectedIndex === -1 && visibleEntries.length > 0) {
        selectEntry(0);
      }
      return;
    }

    if (e.key === 'k') {
      e.preventDefault();
      updateVisibleEntries();
      if (selectedIndex > 0) {
        selectEntry(selectedIndex - 1);
      } else if (selectedIndex === -1 && visibleEntries.length > 0) {
        selectEntry(visibleEntries.length - 1);
      }
      return;
    }

    if (e.key === 'Enter' && selectedIndex >= 0) {
      e.preventDefault();
      navigateToSelected();
      return;
    }

    if (e.key === 'Escape') {
      closeSearch();
      return;
    }

    // gg - go to top
    if (e.key === 'g') {
      updateVisibleEntries();
      if (visibleEntries.length > 0) {
        selectEntry(0);
      }
      return;
    }

    // G - go to bottom
    if (e.key === 'G') {
      updateVisibleEntries();
      if (visibleEntries.length > 0) {
        selectEntry(visibleEntries.length - 1);
      }
      return;
    }
  });

  // Filter on input
  searchInput?.addEventListener('input', (e) => {
    const target = e.target as HTMLInputElement;
    filterEntries(target.value);
  });

  // Initialize
  updateVisibleEntries();
</script>
