---
import BaseLayout from './BaseLayout.astro';
import { getCollection } from 'astro:content';

const { entry } = Astro.props;
const { Content } = await entry.render();

// Get all entries for prev/next navigation
// In production, only show published entries; in dev, show all non-draft entries
const allEntries = await getCollection('journal', ({ data }) =>
  !data.draft && (import.meta.env.DEV || data.published)
);
const sortedEntries = allEntries.sort((a, b) =>
  new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
);
const currentIndex = sortedEntries.findIndex(e => e.slug === entry.slug);
const prevEntry = sortedEntries[currentIndex + 1];
const nextEntry = sortedEntries[currentIndex - 1];

// "On This Day" - find entries from same month-day in previous years
const currentDate = entry.data.date;
const currentMonth = currentDate.getMonth();
const currentDay = currentDate.getDate();
const currentYear = currentDate.getFullYear();

const onThisDayEntries = allEntries
  .filter(e => {
    const d = e.data.date;
    return d.getMonth() === currentMonth &&
           d.getDate() === currentDay &&
           d.getFullYear() !== currentYear;
  })
  .sort((a, b) => b.data.date.getFullYear() - a.data.date.getFullYear());

const formatDate = (date: Date) => {
  return date.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

const formatShortDate = (date: Date) => {
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric'
  });
};

const yearsAgo = (year: number) => {
  const diff = currentYear - year;
  return diff === 1 ? '1 year ago' : `${diff} years ago`;
};

// Word count and reading time
const WORDS_PER_MINUTE = 200;
const wordCount = entry.body
  .replace(/---[\s\S]*?---/, '') // Remove frontmatter
  .replace(/```[\s\S]*?```/g, '') // Remove code blocks
  .replace(/[#*_~`\[\]()>|-]/g, '') // Remove markdown syntax
  .trim()
  .split(/\s+/)
  .filter(word => word.length > 0)
  .length;

const readingTime = Math.max(1, Math.ceil(wordCount / WORDS_PER_MINUTE));

// Generate excerpt for OG description
const excerpt = entry.body
  .replace(/---[\s\S]*?---/, '')
  .replace(/```[\s\S]*?```/g, '')
  .replace(/[#*_~`\[\]()>|-]/g, '')
  .replace(/\n+/g, ' ')
  .trim()
  .slice(0, 150) + '...';

// OG image: use custom if set, otherwise use auto-generated (only for published)
const ogImage = entry.data.og_image || (entry.data.published ? `/og/${entry.slug}.png` : undefined);

// Backlinks: find entries that link to this entry
function extractInternalLinks(body: string): string[] {
  const links: string[] = [];
  const linkRegex = /\[([^\]]+)\]\(\/(\d{4}\/\d{2}\/\d{2})(#[^)]+)?\)/g;
  let match;
  while ((match = linkRegex.exec(body)) !== null) {
    links.push(match[2]);
  }
  return [...new Set(links)];
}

function extractContextSnippet(body: string, targetSlug: string): string {
  // Find sentence containing the link
  const linkPattern = new RegExp(
    `[^.!?\\n]*\\[([^\\]]+)\\]\\(\\/${targetSlug.replace(/\//g, '\\/')}(#[^)]+)?\\)[^.!?\\n]*[.!?]?`,
    'i'
  );
  const match = body.match(linkPattern);
  if (match) {
    let snippet = match[0]
      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
      .replace(/[*_~`]/g, '')
      .trim();
    if (snippet.length > 150) {
      snippet = snippet.slice(0, 147) + '...';
    }
    return snippet;
  }
  return '';
}

const backlinks = allEntries
  .filter(e => {
    if (e.slug === entry.slug) return false;
    const links = extractInternalLinks(e.body);
    return links.includes(entry.slug);
  })
  .map(e => ({
    slug: e.slug,
    title: e.data.title,
    date: e.data.date,
    type: e.data.type,
    context: extractContextSnippet(e.body, entry.slug),
  }))
  .sort((a, b) => b.date.getTime() - a.date.getTime());
---

<BaseLayout
  title={entry.data.title}
  description={excerpt}
  ogImage={ogImage}
  ogType="article"
  publishedTime={entry.data.date}
  tags={entry.data.tags}
>
  <header class="site-header">
    <a href="/">← Archive</a>
  </header>

  <article>
    <header class="entry-header">
      <p class="entry-date">{formatDate(entry.data.date)}</p>
      <div class="entry-meta">
        {entry.data.published && (
          <span class="entry-published" title="Published to public site">PUBLIC</span>
        )}
        <span class="entry-reading-time">{readingTime} min read</span>
        <span class="entry-word-count">{wordCount.toLocaleString()} words</span>
        {entry.data.mood && <span class="entry-mood">Mood: {entry.data.mood}</span>}
        {entry.data.sleep_hours !== undefined && (
          <span class="entry-sleep">Sleep: {entry.data.sleep_hours}h</span>
        )}
        {entry.data.energy !== undefined && (
          <span class="entry-energy">
            Energy: <span class="energy-dots">{'●'.repeat(entry.data.energy)}{'○'.repeat(10 - entry.data.energy)}</span>
          </span>
        )}
      </div>
    </header>

    <div class="entry-content">
      <Content />
    </div>

    {entry.data.tags.length > 0 && (
      <div class="tags">
        {entry.data.tags.map(tag => (
          <a href={`/tags/${tag}`}>#{tag}</a>
        ))}
      </div>
    )}

    {entry.data.habits && entry.data.habits.length > 0 && (
      <div class="habits-display">
        <h3>Habits</h3>
        <ul class="habit-list">
          {entry.data.habits.map(habit => (
            <li class="habit-item">
              {habit.done !== undefined ? (
                <>
                  <span class={`habit-check ${habit.done ? 'done' : ''}`}>
                    {habit.done ? '✓' : '○'}
                  </span>
                  <span class="habit-name">{habit.name}</span>
                </>
              ) : habit.value !== undefined ? (
                <>
                  <span class="habit-value">
                    {habit.value}{habit.goal ? `/${habit.goal}` : ''}
                  </span>
                  <span class="habit-name">{habit.name}</span>
                  {habit.goal && (
                    <span class="habit-progress">
                      <span
                        class="habit-progress-bar"
                        style={`width: ${Math.min(100, (habit.value / habit.goal) * 100)}%`}
                      />
                    </span>
                  )}
                </>
              ) : (
                <span class="habit-name">{habit.name}</span>
              )}
            </li>
          ))}
        </ul>
      </div>
    )}
  </article>

  {onThisDayEntries.length > 0 && (
    <section class="on-this-day">
      <h2>On This Day</h2>
      <ul class="memories-list">
        {onThisDayEntries.map(pastEntry => (
          <li class="memory-item">
            <a href={`/${pastEntry.slug}`}>
              <span class="memory-year">{pastEntry.data.date.getFullYear()}</span>
              <span class="memory-ago">{yearsAgo(pastEntry.data.date.getFullYear())}</span>
              {pastEntry.data.mood && <span class="memory-mood">{pastEntry.data.mood}</span>}
              <span class="memory-title">{pastEntry.data.title}</span>
            </a>
          </li>
        ))}
      </ul>
      <a href="/on-this-day" class="view-all-memories">View all memories →</a>
    </section>
  )}

  {backlinks.length > 0 && (
    <section class="backlinks-section">
      <h2>Referenced By</h2>
      <ul class="backlinks-list">
        {backlinks.map(backlink => (
          <li class="backlink-item">
            <a href={`/${backlink.slug}`} class="backlink-link">
              <span class="backlink-date">{formatShortDate(backlink.date)}</span>
              <span class="backlink-type">{backlink.type}</span>
              <span class="backlink-title">{backlink.title}</span>
            </a>
            {backlink.context && (
              <p class="backlink-context">"{backlink.context}"</p>
            )}
          </li>
        ))}
      </ul>
    </section>
  )}

  <nav class="nav">
    {prevEntry ? (
      <a href={`/${prevEntry.slug}`}>← {formatShortDate(prevEntry.data.date)}</a>
    ) : <span></span>}
    {nextEntry ? (
      <a href={`/${nextEntry.slug}`}>{formatShortDate(nextEntry.data.date)} →</a>
    ) : <span></span>}
  </nav>

  <!-- Link Preview Popup -->
  <div id="link-preview-popup" class="link-preview-popup" role="tooltip" aria-hidden="true">
    <div class="preview-header">
      <span class="preview-type"></span>
      <span class="preview-date"></span>
    </div>
    <h3 class="preview-title"></h3>
    <p class="preview-excerpt"></p>
    <div class="preview-tags"></div>
    <div class="preview-footer">
      <span class="preview-mood"></span>
      <span class="preview-backlinks"></span>
    </div>
  </div>
</BaseLayout>

<style>
  .link-preview-popup {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1000;
    max-width: 320px;
    padding: var(--space-4);
    background: var(--white);
    border: var(--border-thin);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.15s ease, visibility 0.15s ease;
    pointer-events: none;
  }

  .link-preview-popup.visible {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }

  .preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-2);
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    text-transform: uppercase;
    letter-spacing: var(--tracking-widest);
    color: var(--muted-foreground);
  }

  .preview-type {
    padding: 2px 6px;
    background: var(--muted);
  }

  .preview-title {
    font-family: var(--font-display);
    font-size: var(--text-base);
    margin: 0 0 var(--space-2) 0;
    line-height: var(--leading-tight);
  }

  .preview-excerpt {
    font-size: var(--text-sm);
    color: var(--muted-foreground);
    margin: 0 0 var(--space-2) 0;
    line-height: var(--leading-relaxed);
  }

  .preview-tags {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-1);
    margin-bottom: var(--space-2);
  }

  .preview-tags:empty {
    display: none;
  }

  .preview-tags span {
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    color: var(--muted-foreground);
  }

  .preview-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    color: var(--muted-foreground);
  }

  .preview-mood:empty,
  .preview-backlinks:empty {
    display: none;
  }

  .preview-backlinks {
    opacity: 0.7;
  }

  /* Highlight links that have previews */
  .entry-content a[data-has-preview] {
    text-decoration-style: dotted;
  }

  .entry-content a[data-has-preview]:hover {
    text-decoration-style: solid;
  }

  @media (max-width: 640px) {
    .link-preview-popup {
      display: none;
    }
  }

  /* Backlinks Section */
  .backlinks-section {
    margin-top: var(--space-12);
    padding-top: var(--space-8);
    border-top: var(--border-thick);
  }

  .backlinks-section h2 {
    font-family: var(--font-display);
    font-size: var(--text-2xl);
    margin-bottom: var(--space-4);
  }

  .backlinks-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .backlink-item {
    padding: var(--space-4) 0;
    border-bottom: var(--border-hairline);
  }

  .backlink-item:last-child {
    border-bottom: none;
  }

  .backlink-link {
    display: flex;
    align-items: center;
    gap: var(--space-3);
    color: var(--black);
    text-decoration: none;
    transition: background 100ms ease;
    margin: calc(-1 * var(--space-2));
    padding: var(--space-2);
  }

  .backlink-link:hover {
    background: var(--black);
    color: var(--white);
  }

  .backlink-date {
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    text-transform: uppercase;
    letter-spacing: var(--tracking-widest);
    color: var(--muted-foreground);
    min-width: 5rem;
  }

  .backlink-link:hover .backlink-date {
    color: var(--white);
  }

  .backlink-type {
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    text-transform: uppercase;
    letter-spacing: var(--tracking-widest);
    padding: 2px 6px;
    background: var(--muted);
  }

  .backlink-link:hover .backlink-type {
    background: var(--muted-foreground);
    color: var(--white);
  }

  .backlink-title {
    font-family: var(--font-display);
    font-size: var(--text-base);
    flex: 1;
  }

  .backlink-context {
    margin: var(--space-2) 0 0 0;
    padding-left: calc(5rem + var(--space-3));
    font-size: var(--text-sm);
    font-style: italic;
    color: var(--muted-foreground);
    line-height: var(--leading-relaxed);
  }

  @media (max-width: 640px) {
    .backlink-link {
      flex-wrap: wrap;
    }

    .backlink-date {
      min-width: auto;
    }

    .backlink-context {
      padding-left: 0;
    }
  }
</style>

<script>
  import { computePosition, flip, shift, offset } from '@floating-ui/dom';

  // Cache for preview data
  let previewsCache: Record<string, {
    title: string;
    date: string;
    type: string;
    mood: string | null;
    excerpt: string;
    tags: string[];
    backlinkCount: number;
  }> | null = null;

  // Timers for hover delay
  let showTimer: ReturnType<typeof setTimeout> | null = null;
  let hideTimer: ReturnType<typeof setTimeout> | null = null;

  // Current active link
  let activeLink: HTMLAnchorElement | null = null;

  async function loadPreviews() {
    if (previewsCache) return previewsCache;

    try {
      const response = await fetch('/previews.json');
      if (response.ok) {
        previewsCache = await response.json();
        return previewsCache;
      }
    } catch (e) {
      console.error('Failed to load previews:', e);
    }
    return null;
  }

  function getSlugFromHref(href: string): string | null {
    // Handle relative URLs like /2026/01/07
    const match = href.match(/^\/(\d{4}\/\d{2}\/\d{2})$/);
    if (match) {
      return match[1];
    }
    return null;
  }

  async function showPreview(link: HTMLAnchorElement) {
    const popup = document.getElementById('link-preview-popup');
    if (!popup) return;

    const href = link.getAttribute('href');
    if (!href) return;

    const slug = getSlugFromHref(href);
    if (!slug) return;

    const previews = await loadPreviews();
    if (!previews || !previews[slug]) return;

    const preview = previews[slug];

    // Populate popup content
    const typeEl = popup.querySelector('.preview-type');
    const dateEl = popup.querySelector('.preview-date');
    const titleEl = popup.querySelector('.preview-title');
    const excerptEl = popup.querySelector('.preview-excerpt');
    const tagsEl = popup.querySelector('.preview-tags');
    const moodEl = popup.querySelector('.preview-mood');
    const backlinksEl = popup.querySelector('.preview-backlinks');

    if (typeEl) typeEl.textContent = preview.type;
    if (dateEl) dateEl.textContent = preview.date;
    if (titleEl) titleEl.textContent = preview.title;
    if (excerptEl) excerptEl.textContent = preview.excerpt;
    if (tagsEl) {
      tagsEl.innerHTML = preview.tags.map(t => `<span>#${t}</span>`).join('');
    }
    if (moodEl) {
      moodEl.textContent = preview.mood ? `Mood: ${preview.mood}` : '';
    }
    if (backlinksEl) {
      backlinksEl.textContent = preview.backlinkCount > 0
        ? `← ${preview.backlinkCount} reference${preview.backlinkCount !== 1 ? 's' : ''}`
        : '';
    }

    // Position popup using Floating UI
    const { x, y } = await computePosition(link, popup, {
      placement: 'bottom-start',
      middleware: [
        offset(8),
        flip({ fallbackPlacements: ['top-start', 'bottom-end', 'top-end'] }),
        shift({ padding: 8 })
      ]
    });

    popup.style.left = `${x}px`;
    popup.style.top = `${y}px`;
    popup.classList.add('visible');
    popup.setAttribute('aria-hidden', 'false');
    activeLink = link;
  }

  function hidePreview() {
    const popup = document.getElementById('link-preview-popup');
    if (popup) {
      popup.classList.remove('visible');
      popup.setAttribute('aria-hidden', 'true');
    }
    activeLink = null;
  }

  function handleLinkMouseEnter(e: MouseEvent) {
    const link = e.currentTarget as HTMLAnchorElement;

    // Clear any pending hide timer
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }

    // Set show timer with 300ms delay
    showTimer = setTimeout(() => {
      showPreview(link);
    }, 300);
  }

  function handleLinkMouseLeave() {
    // Clear show timer if still pending
    if (showTimer) {
      clearTimeout(showTimer);
      showTimer = null;
    }

    // Set hide timer with 100ms grace period
    hideTimer = setTimeout(() => {
      hidePreview();
    }, 100);
  }

  function handlePopupMouseEnter() {
    // Clear hide timer when entering popup
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }
  }

  function handlePopupMouseLeave() {
    // Hide after leaving popup
    hideTimer = setTimeout(() => {
      hidePreview();
    }, 100);
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (e.key === 'Escape' && activeLink) {
      hidePreview();
    }
  }

  function initLinkPreviews() {
    const contentArea = document.querySelector('.entry-content');
    if (!contentArea) return;

    // Find all internal entry links
    const links = contentArea.querySelectorAll<HTMLAnchorElement>('a[href^="/"]');

    links.forEach(link => {
      const href = link.getAttribute('href');
      if (href && getSlugFromHref(href)) {
        // Mark link as having preview
        link.setAttribute('data-has-preview', 'true');

        // Add event listeners
        link.addEventListener('mouseenter', handleLinkMouseEnter);
        link.addEventListener('mouseleave', handleLinkMouseLeave);
      }
    });

    // Popup hover listeners
    const popup = document.getElementById('link-preview-popup');
    if (popup) {
      popup.addEventListener('mouseenter', handlePopupMouseEnter);
      popup.addEventListener('mouseleave', handlePopupMouseLeave);
    }

    // Keyboard listener
    document.addEventListener('keydown', handleKeyDown);
  }

  // Initialize on DOM ready
  document.addEventListener('DOMContentLoaded', initLinkPreviews);
</script>
