---
import BaseLayout from './BaseLayout.astro';
import { getCollection } from 'astro:content';

const { entry } = Astro.props;
const { Content } = await entry.render();

// Get all entries for prev/next navigation
// In production, only show published entries; in dev, show all non-draft entries
const allEntries = await getCollection('journal', ({ data }) =>
  !data.draft
);
const sortedEntries = allEntries.sort((a, b) =>
  new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
);
const currentIndex = sortedEntries.findIndex(e => e.slug === entry.slug);
const prevEntry = sortedEntries[currentIndex + 1];
const nextEntry = sortedEntries[currentIndex - 1];

// "On This Day" - find entries from same month-day in previous years
const currentDate = entry.data.date;
const currentMonth = currentDate.getMonth();
const currentDay = currentDate.getDate();
const currentYear = currentDate.getFullYear();

const onThisDayEntries = allEntries
  .filter(e => {
    const d = e.data.date;
    return d.getMonth() === currentMonth &&
           d.getDate() === currentDay &&
           d.getFullYear() !== currentYear;
  })
  .sort((a, b) => b.data.date.getFullYear() - a.data.date.getFullYear());

const formatDate = (date: Date) => {
  return date.toLocaleDateString('en-US', {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
};

const formatShortDate = (date: Date) => {
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric'
  });
};

const yearsAgo = (year: number) => {
  const diff = currentYear - year;
  return diff === 1 ? '1 year ago' : `${diff} years ago`;
};

// Word count and reading time
const WORDS_PER_MINUTE = 200;
const wordCount = entry.body
  .replace(/---[\s\S]*?---/, '') // Remove frontmatter
  .replace(/```[\s\S]*?```/g, '') // Remove code blocks
  .replace(/[#*_~`\[\]()>|-]/g, '') // Remove markdown syntax
  .trim()
  .split(/\s+/)
  .filter(word => word.length > 0)
  .length;

const readingTime = Math.max(1, Math.ceil(wordCount / WORDS_PER_MINUTE));

// Generate excerpt for OG description
const excerpt = entry.body
  .replace(/---[\s\S]*?---/, '')
  .replace(/```[\s\S]*?```/g, '')
  .replace(/[#*_~`\[\]()>|-]/g, '')
  .replace(/\n+/g, ' ')
  .trim()
  .slice(0, 150) + '...';

// OG image: use custom if set, otherwise use auto-generated (only for published)
const ogImage = entry.data.og_image || (entry.data.published ? `/og/${entry.slug}.png` : undefined);

// Backlinks: find entries that link to this entry
function extractInternalLinks(body: string): string[] {
  const links: string[] = [];
  const linkRegex = /\[([^\]]+)\]\(\/(\d{4}\/\d{2}\/\d{2})(#[^)]+)?\)/g;
  let match;
  while ((match = linkRegex.exec(body)) !== null) {
    links.push(match[2]);
  }
  return [...new Set(links)];
}

function extractContextSnippet(body: string, targetSlug: string): string {
  // Find sentence containing the link
  const linkPattern = new RegExp(
    `[^.!?\\n]*\\[([^\\]]+)\\]\\(\\/${targetSlug.replace(/\//g, '\\/')}(#[^)]+)?\\)[^.!?\\n]*[.!?]?`,
    'i'
  );
  const match = body.match(linkPattern);
  if (match) {
    let snippet = match[0]
      .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
      .replace(/[*_~`]/g, '')
      .trim();
    if (snippet.length > 150) {
      snippet = snippet.slice(0, 147) + '...';
    }
    return snippet;
  }
  return '';
}

const backlinks = allEntries
  .filter(e => {
    if (e.slug === entry.slug) return false;
    const links = extractInternalLinks(e.body);
    return links.includes(entry.slug);
  })
  .map(e => ({
    slug: e.slug,
    title: e.data.title,
    date: e.data.date,
    type: e.data.type,
    context: extractContextSnippet(e.body, entry.slug),
  }))
  .sort((a, b) => b.date.getTime() - a.date.getTime());

// Similar entries: based on shared tags (Jaccard similarity)
function calculateSimilarity(tagsA: string[], tagsB: string[]): number {
  if (tagsA.length === 0 && tagsB.length === 0) return 0;
  const setA = new Set(tagsA);
  const setB = new Set(tagsB);
  const intersection = [...setA].filter(t => setB.has(t)).length;
  const union = new Set([...setA, ...setB]).size;
  return union > 0 ? intersection / union : 0;
}

function isSameWeek(dateA: Date, dateB: Date): boolean {
  // Get week start (Monday) for each date
  const getWeekStart = (d: Date) => {
    const date = new Date(d);
    const day = date.getDay();
    const diff = date.getDate() - day + (day === 0 ? -6 : 1);
    date.setDate(diff);
    date.setHours(0, 0, 0, 0);
    return date.getTime();
  };
  return getWeekStart(dateA) === getWeekStart(dateB);
}

const entryTags = entry.data.tags || [];
const similarEntries = allEntries
  .filter(e => {
    if (e.slug === entry.slug) return false;
    // Exclude same week entries
    if (isSameWeek(e.data.date, entry.data.date)) return false;
    return true;
  })
  .map(e => ({
    slug: e.slug,
    title: e.data.title,
    date: e.data.date,
    type: e.data.type,
    mood: e.data.mood,
    similarity: calculateSimilarity(entryTags, e.data.tags || []),
  }))
  .filter(e => e.similarity > 0) // Only entries with at least one shared tag
  .sort((a, b) => b.similarity - a.similarity)
  .slice(0, 5); // Top 5 similar entries
---

<BaseLayout
  title={entry.data.title}
  description={excerpt}
  ogImage={ogImage}
  ogType="article"
  publishedTime={entry.data.date}
  tags={entry.data.tags}
>
  <article>
    <header class="entry-header">
      <time class="entry-date">{formatDate(entry.data.date)}</time>
      {entry.data.mood && <span class="entry-mood">{entry.data.mood}</span>}
    </header>

    <div class:list={["entry-content", { "invert-images-dark": entry.data.invert_images }]}>
      <Content />
    </div>

    {entry.data.tags.length > 0 && (
      <div class="tags">
        {entry.data.tags.map(tag => (
          <a href={`/tags/${tag}`}>#{tag}</a>
        ))}
      </div>
    )}

  </article>

  {onThisDayEntries.length > 0 && (
    <section class="on-this-day">
      <h2>On This Day</h2>
      <ul class="memories-list">
        {onThisDayEntries.map(pastEntry => (
          <li class="memory-item">
            <a href={`/${pastEntry.slug}`}>
              <span class="memory-year">{pastEntry.data.date.getFullYear()}</span>
              <span class="memory-ago">{yearsAgo(pastEntry.data.date.getFullYear())}</span>
              {pastEntry.data.mood && <span class="memory-mood">{pastEntry.data.mood}</span>}
              <span class="memory-title">{pastEntry.data.title}</span>
            </a>
          </li>
        ))}
      </ul>
      <a href="/on-this-day" class="view-all-memories">View all memories →</a>
    </section>
  )}

  {backlinks.length > 0 && (
    <section class="backlinks-section">
      <h2>Referenced By</h2>
      <ul class="backlinks-list">
        {backlinks.map(backlink => (
          <li class="backlink-item">
            <a href={`/${backlink.slug}`} class="backlink-link">
              <span class="backlink-date">{formatShortDate(backlink.date)}</span>
              <span class="backlink-type">{backlink.type}</span>
              <span class="backlink-title">{backlink.title}</span>
            </a>
            {backlink.context && (
              <p class="backlink-context">"{backlink.context}"</p>
            )}
          </li>
        ))}
      </ul>
    </section>
  )}

  {similarEntries.length > 0 && (
    <section class="similar-entries-section">
      <h2>Related Entries</h2>
      <ul class="similar-entries-list">
        {similarEntries.map(similar => (
          <li class="similar-entry-item">
            <a href={`/${similar.slug}`} class="similar-entry-link">
              <span class="similar-entry-date">{formatShortDate(similar.date)}</span>
              <span class="similar-entry-title">{similar.title}</span>
              {similar.mood && <span class="similar-entry-mood">{similar.mood}</span>}
            </a>
          </li>
        ))}
      </ul>
    </section>
  )}

  <nav class="nav">
    {prevEntry ? (
      <a href={`/${prevEntry.slug}`}>← {formatShortDate(prevEntry.data.date)}</a>
    ) : <span></span>}
    {nextEntry ? (
      <a href={`/${nextEntry.slug}`}>{formatShortDate(nextEntry.data.date)} →</a>
    ) : <span></span>}
  </nav>

  <!-- Link Preview Popup -->
  <div id="link-preview-popup" class="link-preview-popup" role="tooltip" aria-hidden="true">
    <div class="preview-header">
      <span class="preview-type"></span>
      <span class="preview-date"></span>
    </div>
    <h3 class="preview-title"></h3>
    <p class="preview-excerpt"></p>
    <div class="preview-tags"></div>
    <div class="preview-footer">
      <span class="preview-mood"></span>
      <span class="preview-backlinks"></span>
    </div>
  </div>
</BaseLayout>

<style>
  /* Link Preview Popup - wabi-sabi dark */
  .link-preview-popup {
    position: absolute;
    top: 0;
    left: 0;
    z-index: 1000;
    max-width: 320px;
    padding: 1rem;
    background: var(--bg-elevated);
    border: 1px solid var(--border-color);
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.15s ease, visibility 0.15s ease;
    pointer-events: none;
  }

  .link-preview-popup.visible {
    opacity: 1;
    visibility: visible;
    pointer-events: auto;
  }

  .preview-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    text-transform: lowercase;
    letter-spacing: var(--tracking-wide);
    color: var(--fg-muted);
  }

  .preview-type {
    color: var(--accent);
  }

  .preview-title {
    font-family: var(--font-display);
    font-size: var(--text-sm);
    color: var(--fg);
    margin: 0 0 0.5rem 0;
    line-height: 1.4;
  }

  .preview-excerpt {
    font-size: var(--text-xs);
    color: var(--fg-muted);
    margin: 0 0 0.5rem 0;
    line-height: 1.6;
  }

  .preview-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 0.5rem;
  }

  .preview-tags:empty {
    display: none;
  }

  .preview-tags span {
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    color: var(--fg-muted);
  }

  .preview-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    color: var(--fg-muted);
  }

  .preview-mood:empty,
  .preview-backlinks:empty {
    display: none;
  }

  .preview-backlinks {
    opacity: 0.7;
  }

  @media (max-width: 640px) {
    .link-preview-popup {
      display: none;
    }
  }

  /* Backlinks Section - wabi-sabi */
  .backlinks-section {
    margin-top: 4rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border-color);
  }

  .backlinks-section h2 {
    font-family: var(--font-display);
    font-size: var(--text-lg);
    font-style: italic;
    color: var(--fg-muted);
    margin-bottom: 1rem;
  }

  .backlinks-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .backlink-item {
    padding: 0.75rem 0;
    border-bottom: 1px solid var(--border-color);
  }

  .backlink-item:last-child {
    border-bottom: none;
  }

  .backlink-link {
    display: flex;
    align-items: center;
    gap: 1rem;
    color: var(--fg);
    text-decoration: none;
    border: none;
    transition: opacity 100ms;
  }

  .backlink-link:hover {
    opacity: 0.7;
  }

  .backlink-date {
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    letter-spacing: var(--tracking-wide);
    color: var(--accent);
    min-width: 4rem;
  }

  .backlink-type {
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    text-transform: lowercase;
    letter-spacing: var(--tracking-wide);
    color: var(--fg-muted);
  }

  .backlink-title {
    font-family: var(--font-body);
    font-size: var(--text-sm);
    color: var(--fg-muted);
    flex: 1;
  }

  .backlink-context {
    margin: 0.5rem 0 0 0;
    padding-left: 5rem;
    font-size: var(--text-xs);
    font-style: italic;
    color: var(--fg-muted);
    line-height: 1.6;
  }

  @media (max-width: 640px) {
    .backlink-link {
      flex-wrap: wrap;
    }

    .backlink-date {
      min-width: auto;
    }

    .backlink-context {
      padding-left: 0;
    }
  }

  /* Similar Entries Section - wabi-sabi */
  .similar-entries-section {
    margin-top: 3rem;
    padding-top: 2rem;
    border-top: 1px solid var(--border-color);
  }

  .similar-entries-section h2 {
    font-family: var(--font-display);
    font-size: var(--text-lg);
    font-style: italic;
    color: var(--fg-muted);
    margin-bottom: 1rem;
  }

  .similar-entries-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    gap: 0.5rem;
  }

  .similar-entry-item {
    border-bottom: 1px solid var(--border-color);
  }

  .similar-entry-item:last-child {
    border-bottom: none;
  }

  .similar-entry-link {
    display: flex;
    align-items: center;
    gap: 1rem;
    padding: 0.75rem 0;
    color: var(--fg);
    text-decoration: none;
    border: none;
    transition: opacity 100ms;
  }

  .similar-entry-link:hover {
    opacity: 0.7;
  }

  .similar-entry-date {
    font-family: var(--font-mono);
    font-size: var(--text-xs);
    letter-spacing: var(--tracking-wide);
    color: var(--accent);
    min-width: 4rem;
  }

  .similar-entry-title {
    font-family: var(--font-body);
    font-size: var(--text-sm);
    color: var(--fg-muted);
    flex: 1;
  }

  .similar-entry-mood {
    font-size: var(--text-sm);
  }

  @media (max-width: 640px) {
    .similar-entry-link {
      flex-wrap: wrap;
    }

    .similar-entry-date {
      min-width: auto;
    }
  }
</style>

<script>
  import { computePosition, flip, shift, offset } from '@floating-ui/dom';

  // Cache for preview data
  let previewsCache: Record<string, {
    title: string;
    date: string;
    type: string;
    mood: string | null;
    excerpt: string;
    tags: string[];
    backlinkCount: number;
  }> | null = null;

  // Timers for hover delay
  let showTimer: ReturnType<typeof setTimeout> | null = null;
  let hideTimer: ReturnType<typeof setTimeout> | null = null;

  // Current active link
  let activeLink: HTMLAnchorElement | null = null;

  async function loadPreviews() {
    if (previewsCache) return previewsCache;

    try {
      const response = await fetch('/previews.json');
      if (response.ok) {
        previewsCache = await response.json();
        return previewsCache;
      }
    } catch (e) {
      console.error('Failed to load previews:', e);
    }
    return null;
  }

  function getSlugFromHref(href: string): string | null {
    // Handle relative URLs like /2026/01/07
    const match = href.match(/^\/(\d{4}\/\d{2}\/\d{2})$/);
    if (match) {
      return match[1];
    }
    return null;
  }

  async function showPreview(link: HTMLAnchorElement) {
    const popup = document.getElementById('link-preview-popup');
    if (!popup) return;

    const href = link.getAttribute('href');
    if (!href) return;

    const slug = getSlugFromHref(href);
    if (!slug) return;

    const previews = await loadPreviews();
    if (!previews || !previews[slug]) return;

    const preview = previews[slug];

    // Populate popup content
    const typeEl = popup.querySelector('.preview-type');
    const dateEl = popup.querySelector('.preview-date');
    const titleEl = popup.querySelector('.preview-title');
    const excerptEl = popup.querySelector('.preview-excerpt');
    const tagsEl = popup.querySelector('.preview-tags');
    const moodEl = popup.querySelector('.preview-mood');
    const backlinksEl = popup.querySelector('.preview-backlinks');

    if (typeEl) typeEl.textContent = preview.type;
    if (dateEl) dateEl.textContent = preview.date;
    if (titleEl) titleEl.textContent = preview.title;
    if (excerptEl) excerptEl.textContent = preview.excerpt;
    if (tagsEl) {
      tagsEl.innerHTML = preview.tags.map(t => `<span>#${t}</span>`).join('');
    }
    if (moodEl) {
      moodEl.textContent = preview.mood ? `Mood: ${preview.mood}` : '';
    }
    if (backlinksEl) {
      backlinksEl.textContent = preview.backlinkCount > 0
        ? `← ${preview.backlinkCount} reference${preview.backlinkCount !== 1 ? 's' : ''}`
        : '';
    }

    // Position popup using Floating UI
    const { x, y } = await computePosition(link, popup, {
      placement: 'bottom-start',
      middleware: [
        offset(8),
        flip({ fallbackPlacements: ['top-start', 'bottom-end', 'top-end'] }),
        shift({ padding: 8 })
      ]
    });

    popup.style.left = `${x}px`;
    popup.style.top = `${y}px`;
    popup.classList.add('visible');
    popup.setAttribute('aria-hidden', 'false');
    activeLink = link;
  }

  function hidePreview() {
    const popup = document.getElementById('link-preview-popup');
    if (popup) {
      popup.classList.remove('visible');
      popup.setAttribute('aria-hidden', 'true');
    }
    activeLink = null;
  }

  function handleLinkMouseEnter(e: MouseEvent) {
    const link = e.currentTarget as HTMLAnchorElement;

    // Clear any pending hide timer
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }

    // Set show timer with 300ms delay
    showTimer = setTimeout(() => {
      showPreview(link);
    }, 300);
  }

  function handleLinkMouseLeave() {
    // Clear show timer if still pending
    if (showTimer) {
      clearTimeout(showTimer);
      showTimer = null;
    }

    // Set hide timer with 100ms grace period
    hideTimer = setTimeout(() => {
      hidePreview();
    }, 100);
  }

  function handlePopupMouseEnter() {
    // Clear hide timer when entering popup
    if (hideTimer) {
      clearTimeout(hideTimer);
      hideTimer = null;
    }
  }

  function handlePopupMouseLeave() {
    // Hide after leaving popup
    hideTimer = setTimeout(() => {
      hidePreview();
    }, 100);
  }

  function handleKeyDown(e: KeyboardEvent) {
    if (e.key === 'Escape' && activeLink) {
      hidePreview();
    }
  }

  function initLinkPreviews() {
    const contentArea = document.querySelector('.entry-content');
    if (!contentArea) return;

    // Find all internal entry links
    const links = contentArea.querySelectorAll<HTMLAnchorElement>('a[href^="/"]');

    links.forEach(link => {
      const href = link.getAttribute('href');
      if (href && getSlugFromHref(href)) {
        // Mark link as having preview
        link.setAttribute('data-has-preview', 'true');

        // Add event listeners
        link.addEventListener('mouseenter', handleLinkMouseEnter);
        link.addEventListener('mouseleave', handleLinkMouseLeave);
      }
    });

    // Popup hover listeners
    const popup = document.getElementById('link-preview-popup');
    if (popup) {
      popup.addEventListener('mouseenter', handlePopupMouseEnter);
      popup.addEventListener('mouseleave', handlePopupMouseLeave);
    }

    // Keyboard listener
    document.addEventListener('keydown', handleKeyDown);
  }

  // Initialize on DOM ready
  document.addEventListener('DOMContentLoaded', initLinkPreviews);
</script>
